module Move where

import Prelude
import Control.Monad.Eff (Eff)
import Control.Monad.Eff.Console (CONSOLE, log)
import Data.Functor
import Data.Int
import Signal (Signal, runSignal, foldp, sampleOn, map2)
import Signal.DOM (keyPressed)
import Signal.Time (Time, second, every)

type Model = Int
-- prev is the last place the snake was. This is to erase easily.

inBounds :: Point -> Model -> Boolean
inBounds p m = 
  (getX p > 0) && (getY p > 0) && (getX p <= m.xd) && (getY p <= m.yd)

untilM :: forall m a. (Monad m) => (a -> Boolean) -> m a -> m a
untilM cond ma = 
    do 
      x <- ma
      if cond x then pure x else untilM cond ma

step :: forall e. Partial => Int -> Eff (console :: CONSOLE | e) Model -> Eff (console :: CONSOLE| e) Model --need 2nd argument to be Eff for foldp
step dir m' = 
  do
    m <- m'
    log "move"
    log ("m: " <> (show m.loc))
    pure (m {loc = m.loc + d})

--SIGNALS
inputDir :: Eff _ (Signal Point)
inputDir = 
    let 
        f = \l r -> if l 
                    then -1 
                    else if r
                         then 1
                         else 0
    in
      map2 f <$> (keyPressed 37) <*> (keyPressed 39)

input :: Eff _ (Signal Point)
input = sampleOn (fps 1.0) <$> inputDir

main :: Eff _ Unit
main =
    do
      let game = foldp step (pure 0) dirSignal
      runSignal (map void game)
