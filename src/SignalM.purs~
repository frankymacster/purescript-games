module SignalM where

import Prelude
import Control.Monad.Eff (Eff)
import Control.Monad.Eff.Random (RANDOM)
import Control.Monad.State
import Test.QuickCheck.Gen
import Signal

--runState :: forall s a. State s a -> s -> Tuple a s

foldpM :: forall a b mb c. (mb -> c -> Tuple b c) -> c -> (a -> b -> mb) -> b -> (Signal a) -> (Signal b)
foldpM run st' f st = foldp (\xa (Tuple xb xc) -> uncurry run (Tuple (f xa xb) xc)) (Tuple st st')

foldpR' :: forall a b. GenState -> (a -> b -> Gen b) -> b -> (Signal a) -> (Signal b)
foldpR' = foldpM runGen
-- $ runState . unGen

foldpR :: forall a b e. (a -> b -> Gen b) -> b -> (Signal a) -> Eff (random :: RANDOM | e) (Signal b)
foldpR f st sig = 
    do
      seed <- randomSeed
      foldpR' { newSeed = seed, size = 536870911} f st sig
